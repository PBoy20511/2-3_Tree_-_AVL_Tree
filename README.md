# 2-3_Tree_-_AVL_Tree

# 簡介：
(1) 任務一：

將資料一筆筆讀進來，先將資料新增進去樹裡。Insert的時候會看是哪種節點來決定要如何加入，如果當前節點為空直接加入即可。如果是2-node的話就比較看看當前的key直是大於還是小於來決定要往哪裡走訪，如果是3-node的話也是比較當前的key來看要往左中右哪個child走。如果一個node滿了，就要去分裂它。基本上就是把節點切開之後，中間的往上面擺，剩下的節點變成它的child。當然如果往上面擺造成原parent也滿了，就必須再分裂parent。

(2) 任務二：

將資料一筆筆讀進來，先將資料新增進去樹裡，新增的方法與二元搜尋樹差不多，同樣科系名稱的要放在同個節點，只要有新增節點都要檢查是否樹是否平衡(除了建立root時)，如果左右節點高度差2時要做旋轉，而旋轉有4個情況(新節點插入在右子樹的右子樹則左旋，新節點插入在左子樹的左子樹則右旋，新節點插入在右子樹的左子樹則先左旋再右旋，新節點插入在左子樹的右子樹則先右旋再左旋)，重複以上步驟直到資料都讀完。

(3) 任務三：

因為有可能是看學校名稱或是科系，所以如果要找”所有擁有此科系的學校”，就使用AVL樹來走訪(因為當初是用科系當作key)；剩下的用2-3樹找即可。2-3樹以及AVL樹的走訪都跟它的insertion差不多，唯一的差別在於如果找到當下的節點，要retrive那個值。

心得：

不像上次的作業，2-3樹不適合用array去實作，所以程式用了很多指標和節點，讓人頭疼。2-3樹的分裂真的非常難實作，常常會顧慮不周全，或是邏輯不對，導致程式crash。AVL樹相對起來比較輕鬆，麻煩的部分就是搞清楚哪邊要用哪種rotate，以及節點要怎麼接(常常會接錯或是沒接到)。

# 圖示：
(1) 任務一

(2) 任務二

# 提問：任務一跟任務二的空間效率如何？
解說：
  
任務一	24	112	54

任務二	190	980	1186

任務一明顯比任務二少很多節點，這是因為任務一的2-3樹一個節點可以容納好幾筆資料，所以節點數才會比任務二少。不過用節點數來評斷空間占得多不多不公平，因為2-3樹和avl樹的節點占用空間不一樣，所以不應該用節點數來比較，應該要用記憶體空間來比較。
